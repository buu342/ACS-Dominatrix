#library "domnatrx"
#include "zcommon.acs"
#include "zdaemon.acs"


/*===================================================================================================
                                             Definitions
===================================================================================================*/

#define DUMMY ""        // Needed to prevent text bugs from ocurring
#define VERSION "1.2"
#define SECOND 35

#define MAXPLAYERS 64       // No need to change
#define MAXCONTROLPOINTS 10 // Maximum number of Control points
#define CPPERLINEHUD 10		// Maximum number of CP's per line in your HUD
#define CAPBELOW_HEIGHT 8.0 // Cap below (CVar) tolerance height

// Macros for Message ID's
#define MSGID_CONSOLE  -1
#define MSGID_HUDSTATE 5
#define MSGID_HUDREDS  6
#define MSGID_HUDBLUES 7
#define MSGID_HUDTIME  8
#define MSGID_HUDTIME2 9
#define MSGID_CPCAP1   10
#define MSGID_CPCAP2   11
#define MSGID_CPINFO   21
#define MSGID_CPCOLR   21+MAXCONTROLPOINTS
#define MSGID_CPBACK   21+MAXCONTROLPOINTS*2
#define MSGID_CPINFOSM 21+MAXCONTROLPOINTS*3
#define MSGID_CPCOLRSM 21+MAXCONTROLPOINTS*4
#define MSGID_CPBACKSM 21+MAXCONTROLPOINTS*5

// Macros for translations
#define TRANSLATION_GREY  1
#define TRANSLATION_2BLUE 2
#define TRANSLATION_BLUE  3
#define TRANSLATION_2RED  4
#define TRANSLATION_RED   5

// Macros for Teams
#define TEAM_NONE -1
//#define TEAM_BLUE 0 // Already defined by ZDoom
//#define TEAM_RED 1  // Already defined by ZDoom

// Macros for Thing ID's
#define TID_PLAYER    1337
#define TID_CP        2337
#define TID_CPEYE     TID_CP+MAXCONTROLPOINTS
#define TID_DELETE    3337

// Macros for CP data
#define CPDATA_TID       0
#define CPDATA_TEAM      1
#define CPDATA_CAPAMOUNT 2
#define CPDATA_LASTREGEN 3
#define CPDATA_STATUS    4
#define CPDATA_X         5
#define CPDATA_Y         6
#define CPDATA_Z         7

// Macros for game state
#define GAME_WARMUP  0 // To Implement
#define GAME_RUNNING 1
#define GAME_BLUEWIN 2
#define GAME_REDWIN  3
#define GAME_DRAWWIN 4

// Macros for CP status
#define CPSTATUS_IDLE      0
#define CPSTATUS_BLUECAP   1
#define CPSTATUS_REDCAP    2
#define CPSTATUS_STUCKRED  3
#define CPSTATUS_STUCKBLUE 4

// Macros for announcer sound (negative means team specific)
#define ANNOUNCE_EMPTY     0
#define ANNOUNCE_BLUEGREY  -1
#define ANNOUNCE_REDGREY   -2
#define ANNOUNCE_BLUE      3
#define ANNOUNCE_RED       4
#define ANNOUNCE_REDSCORE  5
#define ANNOUNCE_BLUESCORE 6
#define ANNOUNCE_BLUEWIN   7
#define ANNOUNCE_REDWIN    8
#define ANNOUNCE_DRAWGAME  9
#define ANNOUNCE_50POINTS  10
#define ANNOUNCE_3POINTS   11
#define ANNOUNCE_2POINTS   12
#define ANNOUNCE_1POINT    13
#define ANNOUNCE_1MINUTE   14
#define ANNOUNCE_5MINUTES  15

// Macros for why the game ended
#define END_NONE  0
#define END_SCORE 1
#define END_TIME  2

// Dominatrix SpawnID's
#define T_CPGREY     213
#define T_CPBLUE     214
#define T_CPRED      215
#define T_CPALTAR    216
#define T_CPEYE      217
#define T_CPEYESPIN1 218
#define T_CPEYESPIN2 219

// Animations
#define ANIM_BLUE2GREY 0
#define ANIM_RED2GREY  1
#define ANIM_GREY2BLUE 2
#define ANIM_GREY2RED  3

// Font definitions
#define FONT_FLASHSPEED    6
#define BFONT_STARTCHAR    32
#define BFONT_GREYBACK     BFONT_STARTCHAR+43
#define BFONT_YELLOWBACK   BFONT_GREYBACK+1
#define SFONT_STARTCHAR    32
#define SFONT_GREYBACK     SFONT_STARTCHAR+10
#define SFONT_YELLOWBACK   SFONT_GREYBACK+1
#define SFONT_TEAMCAP      SFONT_YELLOWBACK+1
#define SFONT_WARNING      SFONT_TEAMCAP+1
#define SFONT_MARKERSTART  SFONT_WARNING+1
#define SFONT_MARKERBACK   SFONT_WARNING+6
#define SFONT_MARKERYELLOW SFONT_MARKERSTART+10
#define SFONT_MARKERTEAM   SFONT_MARKERYELLOW+1
#define SFONT_MARKERWARN   SFONT_MARKERTEAM+1


/*===================================================================================================
                                          Global Variables
===================================================================================================*/

bool global_gameinitialized;
int global_controlpoints[MAXCONTROLPOINTS][8];
int global_players[MAXPLAYERS];

int global_cpcount;
int global_cpcountblue;
int global_cpcountred;

int global_gamestate;
int global_gameend;
int global_scoreteamblue;
int global_scoreteamred;
int global_time;
int global_ddomtime;
int global_announcement;
bool global_cpslotmutex;
bool global_zdaemoncompat;


/*===================================================================================================
                                         Dominatrix Scripts
===================================================================================================*/

// Initialize Dominatrix
Script "Dominatrix_Initialize" OPEN
{
	global_cpslotmutex = true;
    global_gameinitialized = true;
    global_cpcount = 0;
    global_cpcountblue = 0;
    global_cpcountred = 0;
    global_scoreteamred = 0;
    global_scoreteamblue = 0;
	global_time = 0;
	global_ddomtime = 0;
	global_announcement = ANNOUNCE_EMPTY;
	global_gameend = END_NONE;
	global_zdaemoncompat = false;

    global_gamestate = GAME_RUNNING;

    // Create translations
    CreateTranslation(TRANSLATION_GREY, 112:127=80:111);
    CreateTranslation(TRANSLATION_2BLUE, 112:127=194:200);
    CreateTranslation(TRANSLATION_BLUE, 112:127=202:207);
    CreateTranslation(TRANSLATION_2RED, 112:127=171:176);
    CreateTranslation(TRANSLATION_RED, 112:127=176:191);

    // Start the main logic script if it's not already started
    ACS_NamedExecute("Dominatrix_Logic", 0);
}

// Set player TID's when entering the game
Script "Dominatrix_PlayerEnter" ENTER
{
    Thing_ChangeTID(0, TID_PLAYER+PlayerNumber());
    global_players[PlayerNumber()] = TID_PLAYER+PlayerNumber();

	// Create the HUD (Zandronum's HUD auto starts)
	if (IsCompatibilityMode("zdaemon"))
		ACS_NamedExecuteAlways("Dominatrix_HUD_ZDaemon", 0);
	else if (IsCompatibilityMode("zdoom"))
		ACS_NamedExecuteAlways("Dominatrix_HUD_ZDoom", 0);
}

// Let people know this server is using Dominatrix (Zandronum Only)
Script "Dominatrix_Advertise" OPEN CLIENTSIDE
{
    if (GetUserCVar(PlayerNumber(), "_dominatrix_advertise"))
    {
        SetUserCVar(PlayerNumber(), "_dominatrix_advertise", false);
        Dominatrix_PrintConsole(StrParam(s:"  This server is using Dominatrix\n",
            s:"           Version ", s:VERSION,
            s:"\n    Created by \cqB\csu\cdu\cq3\cs4\cd2\c- for MDF")
        );
		LocalAmbientSound(StrParam(s:"Dominatrix/Announcer/Welcome", d:random(1, 3)), 127);
    }
}

// Set player TID's when spawning
Script "Dominatrix_PlayerSpawn" RESPAWN
{
    Thing_ChangeTID(0, TID_PLAYER+PlayerNumber());
    global_players[PlayerNumber()] = TID_PLAYER+PlayerNumber();
	if (IsCompatibilityMode("zdaemon"))
		ACS_NamedExecuteAlways("Dominatrix_HUD_ZDaemon", 0);
}

// Remove player TID's when dying and handle frag scoring
Script "Dominatrix_PlayerDie" DEATH
{
	// Reset the player's TID
    //Thing_ChangeTID(TID_PLAYER+PlayerNumber(), 0);
    global_players[PlayerNumber()] = 0;

	// Give the other team points
    if (GetCVar("dominatrix_scorefrag"))
    {
        int plyteam = GetPlayerInfo(PlayerNumber(), PLAYERINFO_TEAM);
        if (plyteam == TEAM_BLUE)
            global_scoreteamred += GetCVar("dominatrix_scoreperfrag")+(GetCVar("dominatrix_scoreperfragcp")*global_cpcountred);
        else if (plyteam == TEAM_RED)
            global_scoreteamblue += GetCVar("dominatrix_scoreperfrag")+(GetCVar("dominatrix_scoreperfragcp")*global_cpcountblue);
    }
}

// Remove player TID's when leaving
Script "Dominatrix_PlayerLeave" (int plynum) DISCONNECT
{
    Thing_ChangeTID(TID_PLAYER+plynum, 0);
    global_players[plynum] = 0;

	// Zandronum kills clientside ACS upon moving to spectator. We need this to reenable the HUD...
	if (IsCompatibilityMode("zandronum") && PlayerIsSpectator(plynum))
		ACS_NamedExecuteAlways("Dominatrix_HUD_Zandronum", 0);
}

// Main gamemode logic thread
Script "Dominatrix_Logic" (void)
{
    ACS_NamedExecute("Dominatrix_HandleControlPoints", 0);
    ACS_NamedExecute("Dominatrix_HandleScore", 0);
    ACS_NamedExecute("Dominatrix_NetworkGlobals", 0);
}

// Control point capture handling
bool temp_playercappingid[MAXPLAYERS];
Script "Dominatrix_HandleControlPoints" (void)
{
	int lastcpHealth = GetCVar("dominatrix_caphealth");
	while (true)
	{
		int i;
		int plytid;
		int plyteam;

		// If the game is over, don't do any more control point handling
		if (global_gamestate != GAME_WARMUP && global_gamestate != GAME_RUNNING)
		{
			// Set all CPs as idle
			for (i=0; i<MAXCONTROLPOINTS; i++)
			{
				// If this control point isn't registered, move to the next one
				if (global_controlpoints[i][CPDATA_TID] == 0)
					continue;
				global_controlpoints[i][CPDATA_STATUS] = CPSTATUS_IDLE;
			}
			terminate;
		}

		// Cycle through all control points
		for (int j=0; j<MAXCONTROLPOINTS; j++)
		{
			int bluecaps = 0;
			int redcaps = 0;

			// If this control point isn't registered, move to the next one
			if (global_controlpoints[j][CPDATA_TID] == 0)
				continue;

			// If there has been a change to the maximum health of a CP, adapt
			if (lastcpHealth != GetCVar("dominatrix_caphealth"))
			{
				int ratio = FixedDiv(GetCVar("dominatrix_caphealth")<<16, lastcpHealth<<16);
				global_controlpoints[j][CPDATA_CAPAMOUNT] = FixedMul(global_controlpoints[j][CPDATA_CAPAMOUNT]<<16, ratio)>>16;
			}

			// Initialize the CP as idle
			global_controlpoints[j][CPDATA_STATUS] = CPSTATUS_IDLE;

			// Cycle through all players to see which teams are capturing this point
			for (i=0; i<MAXPLAYERS; i++)
			{
				plytid = global_players[i];
				plyteam = GetPlayerInfo(plytid-TID_PLAYER, PLAYERINFO_TEAM);

				// If the player doesn't exist, skip him
				if (plytid == 0)
				{
					temp_playercappingid[i] = -1;
					continue;
				}

				// Prevent capping from below
				if (!GetCVar("dominatrix_capbelow") && GetActorZ(plytid)+CAPBELOW_HEIGHT < global_controlpoints[j][CPDATA_Z])
					continue;

				// If a player is near a control point, mark his team as trying to capture it
				if (distance(plytid, global_controlpoints[j][CPDATA_TID]) < GetCVar("dominatrix_capdistance"))
				{
					if (plyteam == TEAM_BLUE)
						bluecaps++;
					else if (plyteam == TEAM_RED)
						redcaps++;
					temp_playercappingid[i] = j;
				}
				else if (temp_playercappingid[i] == j)
					temp_playercappingid[i] = -1;
			}

			// Change the capture amount if only one team is capturing
			if (bluecaps > 0 && redcaps == 0)
			{
				// Ignore if the control point is already captured by the blue team
				if (!GetCVar("dominatrix_capteamregen") && global_controlpoints[j][CPDATA_TEAM] == TEAM_BLUE)
					continue;

				// Ignore if the control point is at max hp
				if (global_controlpoints[j][CPDATA_CAPAMOUNT] >= GetCVar("dominatrix_caphealth"))
				{
					global_controlpoints[j][CPDATA_CAPAMOUNT] = GetCVar("dominatrix_caphealth");
					continue;
				}

				// Add blue's capture to the capture amount
				if (GetCVar("dominatrix_capmultiple"))
					global_controlpoints[j][CPDATA_CAPAMOUNT] += bluecaps;
				else
					global_controlpoints[j][CPDATA_CAPAMOUNT] += 1;

				// Change the capture point's color
				if (global_controlpoints[j][CPDATA_TEAM] == TEAM_RED && global_controlpoints[j][CPDATA_CAPAMOUNT] > 0)
					ACS_NamedExecuteAlways("Dominatrix_SetControlPointTeam", 0, global_controlpoints[j][CPDATA_TID], TEAM_NONE);
				else if (global_controlpoints[j][CPDATA_CAPAMOUNT] >= GetCVar("dominatrix_caphealth"))
					ACS_NamedExecuteAlways("Dominatrix_SetControlPointTeam", 0, global_controlpoints[j][CPDATA_TID], TEAM_BLUE);

				// Mark the CP as being captured by the blue team
				global_controlpoints[j][CPDATA_STATUS] = CPSTATUS_BLUECAP;
			}
			else if (redcaps > 0 && bluecaps == 0)
			{
				// Ignore if the control point is already captured by the red team
				if (!GetCVar("dominatrix_capteamregen") && global_controlpoints[j][CPDATA_TEAM] == TEAM_RED)
					continue;

				// Ignore if the control point is at max hp
				if (global_controlpoints[j][CPDATA_CAPAMOUNT] <= -GetCVar("dominatrix_caphealth"))
				{
					global_controlpoints[j][CPDATA_CAPAMOUNT] = -GetCVar("dominatrix_caphealth");
					continue;
				}

				// Add red's capture to the capture amount
				if (GetCVar("dominatrix_capmultiple"))
					global_controlpoints[j][CPDATA_CAPAMOUNT] -= redcaps;
				else
					global_controlpoints[j][CPDATA_CAPAMOUNT] -= 1;

				// Change the capture point's color
				if (global_controlpoints[j][CPDATA_TEAM] == TEAM_BLUE && global_controlpoints[j][CPDATA_CAPAMOUNT] < 0)
					ACS_NamedExecuteAlways("Dominatrix_SetControlPointTeam", 0, global_controlpoints[j][CPDATA_TID], TEAM_NONE);
				else if (global_controlpoints[j][CPDATA_CAPAMOUNT] <= -GetCVar("dominatrix_caphealth"))
					ACS_NamedExecuteAlways("Dominatrix_SetControlPointTeam", 0, global_controlpoints[j][CPDATA_TID], TEAM_RED);

				// Mark the CP as being captured by the red team
				global_controlpoints[j][CPDATA_STATUS] = CPSTATUS_REDCAP;
			}
			else if (bluecaps == 0 && redcaps == 0)
			{
				// Handle control point health regen
				int capregentime = GetCVar("dominatrix_capregentime");
				int capregenseconds = FixedMul(capregentime, SECOND<<16)>>16;
				if (IsCompatibilityMode("zdaemon"))
					capregenseconds = capregentime*SECOND;
				if (capregentime != 0 && global_controlpoints[j][CPDATA_TEAM] != TEAM_NONE)
				{
					if (abs(global_controlpoints[j][CPDATA_CAPAMOUNT]) != GetCVar("dominatrix_caphealth"))
					{
						if (global_controlpoints[j][CPDATA_LASTREGEN] == 0)
							global_controlpoints[j][CPDATA_LASTREGEN] = Timer()+capregenseconds;
						if (global_controlpoints[j][CPDATA_LASTREGEN] < Timer())
						{
							global_controlpoints[j][CPDATA_LASTREGEN] = Timer()+capregenseconds;
							if (global_controlpoints[j][CPDATA_TEAM] == TEAM_BLUE)
								global_controlpoints[j][CPDATA_CAPAMOUNT] += 1;
							else
								global_controlpoints[j][CPDATA_CAPAMOUNT] -= 1;
						}
					}
				}
			}
			else if (bluecaps > 0 && redcaps > 0)
			{
				if (global_controlpoints[j][CPDATA_CAPAMOUNT] > 0)
					global_controlpoints[j][CPDATA_STATUS] = CPSTATUS_STUCKBLUE;
				else
					global_controlpoints[j][CPDATA_STATUS] = CPSTATUS_STUCKRED;
			}
		}

		lastcpHealth = GetCVar("dominatrix_caphealth");
		delay(1);
	}
}

// Handle team score
Script "Dominatrix_HandleScore" (void)
{
	// Wait a little bit for CP's to spawn and stuff
	delay(5);

	int dynamicTimeExtra = GetCVar("dominatrix_timelimitpercp")*global_cpcount + GetCVar("dominatrix_timelimitperplayer")*PlayerCount();
    int timecur = Timer();
    int timetoscore = timecur+((FixedMul(SECOND<<16, GetCVar("dominatrix_scoretime")))>>16);
	if (IsCompatibilityMode("zdaemon"))
		timetoscore = timecur+SECOND*GetCVar("dominatrix_scoretime");
	if (GetCVar("dominatrix_ddommode"))
		timetoscore = 0;
    int timewarmup = timecur + GetCVar("dominatrix_timewarmup")*SECOND;
    int timetoend = timewarmup;
    if (global_gamestate == GAME_RUNNING)
        timetoend = timecur+(GetCVar("dominatrix_timemax")+dynamicTimeExtra)*SECOND;
	bool announced50P = false;
	bool announced3P = false;
	bool announced2P = false;
	bool announced1P = false;

	// Don't touch the game logic if no one's playing currently
	if (PlayerCount() == 0)
	{
		delay(1);
		restart;
	}

	// Game logic
    while (true)
    {
        timecur = Timer();

        // Add score after some time
        if ((GetCVar("dominatrix_ddommode") || GetCVar("dominatrix_scoretime") != 0) && timetoscore < timecur)
        {
			// If not in double domination mode, give score every X seconds
			if (!GetCVar("dominatrix_ddommode"))
			{
				global_scoreteamblue += GetCVar("dominatrix_scorepercp")*global_cpcountblue;
				global_scoreteamred += GetCVar("dominatrix_scorepercp")*global_cpcountred;
				if (IsCompatibilityMode("zdaemon"))
					timetoscore = timecur+SECOND*GetCVar("dominatrix_scoretime");
				else
					timetoscore = timecur+((FixedMul(SECOND<<16, GetCVar("dominatrix_scoretime")))>>16);
			}
			else if (timetoscore != 0)
			{
				// Give points to the winning team
				if (global_cpcountblue == global_cpcount)
				{
					global_scoreteamblue++;
					global_announcement = ANNOUNCE_BLUESCORE;
				}
				else if (global_cpcountred == global_cpcount)
				{
					global_scoreteamred++;
					global_announcement = ANNOUNCE_REDSCORE;
				}

				// Reset all the CP's back to grey if the ConVar is enabled
				if (GetCVar("dominatrix_ddomresetonscore"))
				{
					// Cycle through all control points
					for (int k=0; k<MAXCONTROLPOINTS; k++)
					{
						// If this control point isn't registered, move to the next one
						if (global_controlpoints[k][CPDATA_TID] == 0)
							continue;

						// Set it back to grey
						ACS_NamedExecuteAlways("Dominatrix_SetControlPointTeam", 0, global_controlpoints[k][CPDATA_TID], TEAM_NONE, true);
					}
				}
				timetoscore = 0;
			}
        }

        // Handle warmup time up
        if (global_gamestate == GAME_WARMUP && timewarmup <= timecur)
        {
            ResetMap();
            global_gamestate = GAME_RUNNING;
            timetoend = timecur+GetCVar("dominatrix_timemax")*SECOND;
        }

		// Handle Double Domination
		if (GetCVar("dominatrix_ddommode"))
		{
			// If the time hasn't started decrementing and a team has all the CP's, start counting down
			if ((global_cpcountblue == global_cpcount || global_cpcountred == global_cpcount) && timetoscore == 0)
				timetoscore = Timer() + GetCVar("dominatrix_ddomscoretime")*SECOND;

			// If a team lost a CP, kill the timer
			if (global_cpcountblue != global_cpcount && global_cpcountred != global_cpcount)
				timetoscore = 0;
		}

        // Handle winning
        if (GetCVar("dominatrix_scoremax") != 0 || GetCVar("dominatrix_timemax") != 0)
        {
			int dynamicScoreExtra = GetCVar("dominatrix_scorelimitpercp")*global_cpcount + GetCVar("dominatrix_scorelimitperplayer")*PlayerCount();
			int maxscore = GetCVar("dominatrix_scoremax")+dynamicScoreExtra;

            bool timeup  = (timetoend-timecur) <= 0;
            bool scoreup = maxscore <= global_scoreteamblue || maxscore <= global_scoreteamred;

            // If time is up or a team beat the max score
            if ((GetCVar("dominatrix_timemax") != 0 && timeup) || (GetCVar("dominatrix_scoremax") != 0 && scoreup))
            {
				str tally = "";

                // Decide how the game ended
                if ((global_scoreteamblue >= maxscore && global_scoreteamred < maxscore) || global_scoreteamblue > global_scoreteamred)
				{
					tally = "Blue team wins!\n";
                    global_gamestate = GAME_BLUEWIN;
					global_announcement = ANNOUNCE_BLUEWIN;
				}
                else if ((global_scoreteamred >= maxscore && global_scoreteamblue < maxscore) || global_scoreteamblue < global_scoreteamred)
				{
					tally = "Red team wins!\n";
                    global_gamestate = GAME_REDWIN;
					global_announcement = ANNOUNCE_REDWIN;
				}
                else
				{
					tally = "No team wins!\n";
                    global_gamestate = GAME_DRAWWIN;
					global_announcement = ANNOUNCE_DRAWGAME;
				}

				// State why the game ended
				if (GetCVar("dominatrix_timemax") != 0 && timeup)
					global_gameend = END_TIME;
				else
					global_gameend = END_SCORE;

                // Freeze all the players
                SetPlayerProperty(1, 1, PROP_TOTALLYFROZEN);
                SetPlayerProperty(1, 2, PROP_INVULNERABILITY);

				// Set the "official" team scores
				if (IsCompatibilityMode("Zandronum"))
				{
					Team_GivePoints(TEAM_RED, global_scoreteamred, false);
					Team_GivePoints(TEAM_BLUE, global_scoreteamblue, false);
				}
				else
				{
					SetTeamScore(TEAM_BLUE, global_scoreteamblue);
					SetTeamScore(TEAM_RED, global_scoreteamred);
				}

				// Print to the console the final tally
				tally = StrParam(s:tally, s:"Blue team score: ", d:global_scoreteamblue, s:"\nRed team score: ", d:global_scoreteamred);
				Dominatrix_PrintConsoleBold(tally);

				// End the game after X seconds
                delay(SECOND*GetCVar("dominatrix_roundendtime"));
                Exit_Normal(0);
            }

			// Handle announcer time/score
			if (GetCVar("dominatrix_timemax") > 300 && timetoend-timecur == 300*SECOND)
				global_announcement = ANNOUNCE_5MINUTES;
			if (GetCVar("dominatrix_timemax") > 60 && timetoend-timecur == 60*SECOND)
				global_announcement = ANNOUNCE_1MINUTE;
			if (!announced3P && GetCVar("dominatrix_ddommode"))
			{
				if (GetCVar("dominatrix_scoremax") > 3 && ((GetCVar("dominatrix_scoremax")-global_scoreteamblue == 3) || (GetCVar("dominatrix_scoremax")-global_scoreteamred == 3)))
				{
					global_announcement = ANNOUNCE_3POINTS;
					announced3P = true;
				}
			}
			if (!announced2P && GetCVar("dominatrix_ddommode"))
			{
				if (GetCVar("dominatrix_scoremax") > 2 && ((GetCVar("dominatrix_scoremax")-global_scoreteamblue == 2) || (GetCVar("dominatrix_scoremax")-global_scoreteamred == 2)))
				{
					global_announcement = ANNOUNCE_2POINTS;
					announced2P = true;
				}
			}
			if (!announced1P && GetCVar("dominatrix_ddommode"))
			{
				if (GetCVar("dominatrix_scoremax") > 1 && ((GetCVar("dominatrix_scoremax")-global_scoreteamblue == 1) || (GetCVar("dominatrix_scoremax")-global_scoreteamred == 1)))
				{
					global_announcement = ANNOUNCE_1POINT;
					announced1P = true;
				}
			}
			if (!announced50P && !GetCVar("dominatrix_ddommode"))
			{
				if (GetCVar("dominatrix_scoremax") > 50 && ((GetCVar("dominatrix_scoremax")-global_scoreteamblue < 51) || (GetCVar("dominatrix_scoremax")-global_scoreteamred < 51)))
				{
					global_announcement = ANNOUNCE_50POINTS;
					announced50P = true;
				}
			}

			// Update global variables
			global_time = timetoend;
			if (GetCVar("dominatrix_ddommode"))
			{
				global_ddomtime = timetoscore;
				if (global_cpcountred == global_cpcount)
					global_ddomtime = -global_ddomtime; // Negative time so on the HUD we can tell the red team has the points
			}
			delay(1);
		}
	}
}

// Network serverside globals to clients
Script "Dominatrix_NetworkGlobals" (void)
{
	/*
		What is happening here?
		Zandronum does not network global variables to clients, so as a result when you try to retrieve a global variable clientsided,
		it always returns 0. My solution to fix that is to stick the values in a Server CVar, which allows us to send a myriad of data
		(like strings). In most cases, ints/floats are used. When I need to transfer stuff that's in an array, however, I pack the data
		into a string instead, where every new line of the string represents a new index of the array. This, of course, requires an
		auxillary code to both convert the strings back to ints (AToI) and another to unpack the data.
		I used this method in DoomWare and it works great. I should probably write a guide on this in the future...
		This system isn't used in ZDaemon because clients can't access server CVars. Not a problem as the HUD isn't clientside in ZDaemon
		due to all sorts of incompatibilities (mainly, no way to network data).
	*/

	global_zdaemoncompat = IsCompatibilityMode("zdaemon");
	if (!IsCompatibilityMode("zdaemon"))
	{
		str cpinfo1 = "";
		str cpinfo2 = "";
		SetGlobalCVar("__clientsync_redscore", global_scoreteamred);
		SetGlobalCVar("__clientsync_bluescore", global_scoreteamblue);
		SetGlobalCVar("__clientsync_gamestate", global_gamestate);
		SetGlobalCVar("__clientsync_cpcount", global_cpcount);
		SetGlobalCVar("__clientsync_time", global_time);
		SetGlobalCVar("__clientsync_announce", global_announcement);
		SetGlobalCVar("__clientsync_gameend", global_gameend);
		SetGlobalCVar("__clientsync_ddomtime", global_ddomtime);

		// Pack the control point info into a string
		for (int i=0; i<MAXCONTROLPOINTS; i++)
		{
			if (global_controlpoints[i][CPDATA_TID] != 0)
			{
				// Network the coordinates of the control point
				cpinfo1 = StrParam(s:cpinfo1, d:global_controlpoints[i][CPDATA_X], s:" ",
											  d:global_controlpoints[i][CPDATA_Y], s:" ",
											  d:global_controlpoints[i][CPDATA_Z], c:'\n');

				// Network the other control point data
				cpinfo2 = StrParam(s:cpinfo2, d:global_controlpoints[i][CPDATA_TEAM], s:" ",
											  d:global_controlpoints[i][CPDATA_STATUS], s:" ",
											  d:global_controlpoints[i][CPDATA_CAPAMOUNT], c:'\n');
			}
		}
		SetGlobalCVarString("__clientsync_cpinfo1", cpinfo1);
		SetGlobalCVarString("__clientsync_cpinfo2", cpinfo2);
	}
	global_announcement = ANNOUNCE_EMPTY;

	delay(1);
    restart;
}

// HUD - Zandronum
Script "Dominatrix_HUD_Zandronum" OPEN CLIENTSIDE
{
	// Only execute this in Zandronum
	if (!IsCompatibilityMode("zandronum"))
		terminate;

	// Execute the announcer thread
	if (!GetUserCVar(ConsolePlayerNumber(), "dominatrix_disableannouncer"))
		ACS_NamedExecuteAlways("Dominatrix_Announcer_Zandronum", 0, ConsolePlayerNumber());

	// Draw every frame
	HUDClear();
	while (true)
	{
		SetActivatorToPlayer(ConsolePlayerNumber());
		HUDLoop(ConsolePlayerNumber(), PlayerIsSpectator(ConsolePlayerNumber()));
		delay(1);
	}
}

// HUD - ZDoom
Script "Dominatrix_HUD_ZDoom" (void)
{
    int plynum = PlayerNumber();
    SetActivator(TID_PLAYER+plynum);

	// Execute the announcer thread
	if (!GetUserCVar(plynum, "dominatrix_disableannouncer"))
		ACS_NamedExecuteAlways("Dominatrix_Announcer_ZDoom", 0, plynum);

	// Draw every frame
	while (PlayerInGame(plynum))
	{
		HUDLoop(plynum, false);
		delay(1);
		HUDClear();
	}
}

// HUD - ZDaemon
Script "Dominatrix_HUD_ZDaemon" (void)
{
    SetActivator(TID_PLAYER+PlayerNumber());

	// Execute the announcer thread
	if (!GetCVar("dominatrix_disableannouncer"))
		ACS_NamedExecuteAlways("Dominatrix_Announcer_ZDaemon", 0, PlayerNumber());

	// Draw every frame
	while (PlayerNumber() != -1 && PlayerInGame(PlayerNumber()))
	{
		HUDLoop(PlayerNumber(), false);
		delay(1);
		HUDClear();
	}
}

// Handle the announcer (Zandronum)
Script "Dominatrix_Announcer_Zandronum" (int plynum) CLIENTSIDE
{
	int announcement1 = ANNOUNCE_EMPTY;
	int announcement2 = ANNOUNCE_EMPTY;
	int announcement3 = ANNOUNCE_EMPTY;
	int nextAnnouncement = 0;

	while (true)
	{
		bool isSpectator = !PlayerInGame(plynum);
		int announcement = GetGlobalCVar("__clientsync_announce");

		// If spectator, don't run any code below
		if (isSpectator)
		{
			delay(1);
			continue;
		}
		SetActivatorToPlayer(plynum);

		// Check if a team specific announcement
		if (announcement < 0)
		{
			switch(announcement)
			{
				case ANNOUNCE_BLUEGREY:
					if (GetPlayerInfo(plynum, PLAYERINFO_TEAM) != TEAM_BLUE)
						announcement = 0;
					break;
				case ANNOUNCE_REDGREY:
					if (GetPlayerInfo(plynum, PLAYERINFO_TEAM) != TEAM_RED)
						announcement = 0;
					break;
			}
		}

		// Find an empty position in our announcement "stack"
		if (announcement != ANNOUNCE_EMPTY)
		{
			if (announcement1 == ANNOUNCE_EMPTY)
				announcement1 = announcement;
			else if (announcement2 == ANNOUNCE_EMPTY)
				announcement2 = announcement;
			else if (announcement2 == ANNOUNCE_EMPTY)
				announcement3 = announcement;
		}

		// Execute an announcement
		if (nextAnnouncement == 0 && announcement1 != ANNOUNCE_EMPTY)
		{
			PlayAnnouncement(plynum, announcement1);
			announcement1 = announcement2;
			announcement2 = announcement3;
			announcement3 = ANNOUNCE_EMPTY;
			nextAnnouncement = SECOND*2;
		}

		// Decrease the time to execute the next announcement
		if (nextAnnouncement > 0)
			nextAnnouncement--;
		delay(1);
	}
}

// Handle the announcer (ZDoom)
Script "Dominatrix_Announcer_ZDoom" (int plynum)
{
	int announcement1 = ANNOUNCE_EMPTY;
	int announcement2 = ANNOUNCE_EMPTY;
	int announcement3 = ANNOUNCE_EMPTY;
	int nextAnnouncement = 0;
	while (PlayerInGame(plynum))
	{
		int announcement = GetGlobalCVar("__clientsync_announce");

		// Check if a team specific announcement
		if (announcement < 0)
		{
			switch(announcement)
			{
				case ANNOUNCE_BLUEGREY:
					if (GetPlayerInfo(plynum, PLAYERINFO_TEAM) != TEAM_BLUE)
						announcement = 0;
					break;
				case ANNOUNCE_REDGREY:
					if (GetPlayerInfo(plynum, PLAYERINFO_TEAM) != TEAM_RED)
						announcement = 0;
					break;
			}
		}

		// Find an empty position in our announcement "stack"
		if (announcement != ANNOUNCE_EMPTY)
		{
			if (announcement1 == ANNOUNCE_EMPTY)
				announcement1 = announcement;
			else if (announcement2 == ANNOUNCE_EMPTY)
				announcement2 = announcement;
			else if (announcement2 == ANNOUNCE_EMPTY)
				announcement3 = announcement;
		}

		// Execute an announcement
		if (nextAnnouncement == 0 && announcement1 != ANNOUNCE_EMPTY)
		{
			PlayAnnouncement(plynum, announcement1);
			announcement1 = announcement2;
			announcement2 = announcement3;
			announcement3 = ANNOUNCE_EMPTY;
			nextAnnouncement = SECOND*2;
		}

		// Decrease the time to execute the next announcement
		if (nextAnnouncement > 0)
			nextAnnouncement--;
		delay(1);
	}
}

// Handle the announcer (ZDaemon)
Script "Dominatrix_Announcer_ZDaemon" (int plynum)
{
	int announcement1 = ANNOUNCE_EMPTY;
	int announcement2 = ANNOUNCE_EMPTY;
	int announcement3 = ANNOUNCE_EMPTY;
	int nextAnnouncement = 0;
	while (PlayerNumber() != -1 && PlayerInGame(plynum))
	{
		int announcement = GetGlobalCVar("__clientsync_announce");

		// Check if a team specific announcement
		if (announcement < 0)
		{
			switch(announcement)
			{
				case ANNOUNCE_BLUEGREY:
					if (GetPlayerInfo(plynum, PLAYERINFO_TEAM) != TEAM_BLUE)
						announcement = 0;
					break;
				case ANNOUNCE_REDGREY:
					if (GetPlayerInfo(plynum, PLAYERINFO_TEAM) != TEAM_RED)
						announcement = 0;
					break;
			}
		}

		// Find an empty position in our announcement "stack"
		if (nextAnnouncement == 0 && announcement != ANNOUNCE_EMPTY)
		{
			if (announcement1 == ANNOUNCE_EMPTY)
				announcement1 = announcement;
			else if (announcement2 == ANNOUNCE_EMPTY)
				announcement2 = announcement;
			else if (announcement2 == ANNOUNCE_EMPTY)
				announcement3 = announcement;
		}

		// Execute an announcement
		if (announcement1 != ANNOUNCE_EMPTY)
		{
			PlayAnnouncement(plynum, announcement1);
			announcement1 = announcement2;
			announcement2 = announcement3;
			announcement3 = ANNOUNCE_EMPTY;
			nextAnnouncement = SECOND*2;
		}

		// Decrease the time to execute the next announcement
		if (nextAnnouncement > 0)
			nextAnnouncement--;
		delay(1);
	}
}


/*===================================================================================================
                                      Dominatrix Useful Scripts
===================================================================================================*/

// Adds a control point
// Argument 0 - A fixed point X coordinate
// Argument 1 - A fixed point Y coordinate
// Argument 2 - A fixed point Z coordinate
Script "Dominatrix_AddControlPoint" (int x, int y, int z)
{
    // If no coordinates are given, get the actor position
    if (x == -1 && y == -1 && z == -1)
    {
        x = GetActorX(0);
        y = GetActorY(0);
        z = GetActorZ(0);
    }

	// Find a free CP slot
    int index = -2;
    while (index == -2)
	{
        index = Dominatrix_FindEmptyCP();
		if (index == -1)
			terminate;
		delay(1);
	}

    // Spawn the Altar and Eye (Done like this for ZDaemon Compatibility)
	SpawnForced("MapSpot", x, y, z, TID_DELETE, 0.0);
	Thing_SpawnNoFog(TID_DELETE, T_CPALTAR, 0.0, global_controlpoints[index][CPDATA_TID]);
	Thing_SpawnNoFog(TID_DELETE, T_CPEYE, 0.0, global_controlpoints[index][CPDATA_TID]+MAXCONTROLPOINTS);
	Thing_Remove(TID_DELETE);
    global_cpcount++;

    // Setup the altar
    ACS_NamedExecuteAlways("Dominatrix_ApplyTranslation", 0, global_controlpoints[index][CPDATA_TID]+MAXCONTROLPOINTS, TRANSLATION_GREY);
    global_controlpoints[index][CPDATA_TEAM] = TEAM_NONE;
	global_controlpoints[index][CPDATA_X] = x;
	global_controlpoints[index][CPDATA_Y] = y;
	global_controlpoints[index][CPDATA_Z] = z;
}
script 24290 (int x, int y, int z) // Proxy script for ZDaemon DEHACKED Support
{
	ACS_NamedExecuteAlways("Dominatrix_AddControlPoint", 0, x, y, z);
}

// Adds a control point for the blue team
// Argument 0 - A fixed point X coordinate
// Argument 1 - A fixed point Y coordinate
// Argument 2 - A fixed point Z coordinate
Script "Dominatrix_AddControlPointBlue" (int x, int y, int z)
{
    // If no coordinates are given, get the actor position
    if (x == -1 && y == -1 && z == -1)
    {
        x = GetActorX(0);
        y = GetActorY(0);
        z = GetActorZ(0);
    }

	// Find a free CP slot
    int index = -2;
    while (index == -2)
	{
        index = Dominatrix_FindEmptyCP();
		if (index == -1)
			terminate;
		delay(1);
	}

    // Spawn the Altar and Eye (Done like this for ZDaemon Compatibility)
	SpawnForced("MapSpot", x, y, z, TID_DELETE, 0.0);
	Thing_SpawnNoFog(TID_DELETE, T_CPALTAR, 0.0, global_controlpoints[index][CPDATA_TID]);
	Thing_SpawnNoFog(TID_DELETE, T_CPEYE, 0.0, global_controlpoints[index][CPDATA_TID]+MAXCONTROLPOINTS);
	Thing_Remove(TID_DELETE);
    global_cpcount++;
    global_cpcountblue++;

    // Setup the altar
    ACS_NamedExecuteAlways("Dominatrix_ApplyTranslation", 0, global_controlpoints[index][CPDATA_TID]+MAXCONTROLPOINTS, TRANSLATION_BLUE);
    global_controlpoints[index][CPDATA_CAPAMOUNT] = GetCVar("dominatrix_caphealth");
    global_controlpoints[index][CPDATA_TEAM] = TEAM_BLUE;
	global_controlpoints[index][CPDATA_X] = x;
	global_controlpoints[index][CPDATA_Y] = y;
	global_controlpoints[index][CPDATA_Z] = z;
}
script 24291 (int x, int y, int z) // Proxy script for ZDaemon DEHACKED Support
{
	ACS_NamedExecuteAlways("Dominatrix_AddControlPointBlue", 0, x, y, z);
}

// Adds a control point for the red team
// Argument 0 - A fixed point X coordinate
// Argument 1 - A fixed point Y coordinate
// Argument 2 - A fixed point Z coordinate
Script "Dominatrix_AddControlPointRed" (int x, int y, int z)
{
    // If no coordinates are given, get the actor position
    if (x == -1 && y == -1 && z == -1)
    {
        x = GetActorX(0);
        y = GetActorY(0);
        z = GetActorZ(0);
    }

	// Find a free CP slot
    int index = -2;
    while (index == -2)
	{
        index = Dominatrix_FindEmptyCP();
		if (index == -1)
			terminate;
		delay(1);
	}

    // Spawn the Altar and Eye (Done like this for ZDaemon Compatibility)
	SpawnForced("MapSpot", x, y, z, TID_DELETE, 0.0);
	Thing_SpawnNoFog(TID_DELETE, T_CPALTAR, 0.0, global_controlpoints[index][CPDATA_TID]);
	Thing_SpawnNoFog(TID_DELETE, T_CPEYE, 0.0, global_controlpoints[index][CPDATA_TID]+MAXCONTROLPOINTS);
	Thing_Remove(TID_DELETE);
    global_cpcount++;
    global_cpcountred++;

    // Setup the altar
    ACS_NamedExecuteAlways("Dominatrix_ApplyTranslation", 0, global_controlpoints[index][CPDATA_TID]+MAXCONTROLPOINTS, TRANSLATION_RED);
    global_controlpoints[index][CPDATA_CAPAMOUNT] = -GetCVar("dominatrix_caphealth");
    global_controlpoints[index][CPDATA_TEAM] = TEAM_RED;
	global_controlpoints[index][CPDATA_X] = x;
	global_controlpoints[index][CPDATA_Y] = y;
	global_controlpoints[index][CPDATA_Z] = z;
}
script 24292 (int x, int y, int z) // Proxy script for ZDaemon DEHACKED Support
{
	ACS_NamedExecuteAlways("Dominatrix_AddControlPointRed", 0, x, y, z);
}

// Set the control point to the specified team
// Argument 0 - The TID of the control point
// Argument 1 - The team to set the control point to
Script "Dominatrix_SetControlPointTeam" (int tid, int team, int silent)
{
    if (tid == 0)
        tid = ActivatorTID();

    if (global_controlpoints[tid-TID_CP][CPDATA_TEAM] == TEAM_NONE && team == TEAM_BLUE)
    {
        global_controlpoints[tid-TID_CP][CPDATA_CAPAMOUNT] = GetCVar("dominatrix_caphealth");
        global_cpcountblue++;
		if (!silent)
			global_announcement = ANNOUNCE_BLUE;
		ACS_NamedExecuteAlways("Dominatrix_DoControlPointAnimation", 0, tid, ANIM_GREY2BLUE);
    }
    if (global_controlpoints[tid-TID_CP][CPDATA_TEAM] == TEAM_NONE && team == TEAM_RED)
    {
        global_controlpoints[tid-TID_CP][CPDATA_CAPAMOUNT] = -GetCVar("dominatrix_caphealth");
        global_cpcountred++;
		if (!silent)
			global_announcement = ANNOUNCE_RED;
		ACS_NamedExecuteAlways("Dominatrix_DoControlPointAnimation", 0, tid, ANIM_GREY2RED);
    }
    if (global_controlpoints[tid-TID_CP][CPDATA_TEAM] == TEAM_BLUE && team == TEAM_NONE)
    {
        global_controlpoints[tid-TID_CP][CPDATA_CAPAMOUNT] = 0;
        global_cpcountblue--;
		if (!silent)
			global_announcement = ANNOUNCE_BLUEGREY;

		ACS_NamedExecuteAlways("Dominatrix_DoControlPointAnimation", 0, tid, ANIM_BLUE2GREY);
    }
    if (global_controlpoints[tid-TID_CP][CPDATA_TEAM] == TEAM_RED && team == TEAM_NONE)
    {
        global_controlpoints[tid-TID_CP][CPDATA_CAPAMOUNT] = 0;
        global_cpcountred--;
		if (!silent)
			global_announcement = ANNOUNCE_REDGREY;
		ACS_NamedExecuteAlways("Dominatrix_DoControlPointAnimation", 0, tid, ANIM_RED2GREY);
    }
	global_controlpoints[tid-TID_CP][CPDATA_TEAM] = team;

}

// Apply a translation to an actor
// Argument 0 - The TID of the actor
// Argument 1 - The translation ID to apply
Script "Dominatrix_ApplyTranslation" (int tid, int translation)
{
    Thing_SetTranslation(tid, translation);
}

// Performs an animation on a control point eye
// Argument 0 - The TID of the Control point altar
// Argument 1 - The animation to perform
Script "Dominatrix_DoControlPointAnimation" (int tid, int animation)
{
	// If using ZDaemon, do the animation manually
	if (IsCompatibilityMode("zdaemon"))
	{
		Thing_Remove(tid+MAXCONTROLPOINTS);
		switch (animation)
		{
			case ANIM_GREY2BLUE:
			case ANIM_GREY2RED:
				Thing_SpawnNoFog(tid, T_CPEYESPIN1, 0.0, tid+MAXCONTROLPOINTS);
				ACS_NamedExecuteAlways("Dominatrix_ApplyTranslation", 0, tid+MAXCONTROLPOINTS, TRANSLATION_GREY);
				break;
			case ANIM_BLUE2GREY:
				Thing_SpawnNoFog(tid, T_CPEYESPIN2, 0.0, tid+MAXCONTROLPOINTS);
				ACS_NamedExecuteAlways("Dominatrix_ApplyTranslation", 0, tid+MAXCONTROLPOINTS, TRANSLATION_BLUE);
				break;
			case ANIM_RED2GREY:
				Thing_SpawnNoFog(tid, T_CPEYESPIN2, 0.0, tid+MAXCONTROLPOINTS);
				ACS_NamedExecuteAlways("Dominatrix_ApplyTranslation", 0, tid+MAXCONTROLPOINTS, TRANSLATION_RED);
				break;
		}
		delay(6);
		switch (animation)
		{
			case ANIM_GREY2BLUE:
			case ANIM_BLUE2GREY: ACS_NamedExecuteAlways("Dominatrix_ApplyTranslation", 0, tid+MAXCONTROLPOINTS, TRANSLATION_2BLUE); break;
			case ANIM_GREY2RED:
			case ANIM_RED2GREY:  ACS_NamedExecuteAlways("Dominatrix_ApplyTranslation", 0, tid+MAXCONTROLPOINTS, TRANSLATION_2RED); break;
		}
		delay(12);
		switch (animation)
		{
			case ANIM_GREY2BLUE: ACS_NamedExecuteAlways("Dominatrix_ApplyTranslation", 0, tid+MAXCONTROLPOINTS, TRANSLATION_BLUE); break;
			case ANIM_GREY2RED:  ACS_NamedExecuteAlways("Dominatrix_ApplyTranslation", 0, tid+MAXCONTROLPOINTS, TRANSLATION_RED); break;
			case ANIM_BLUE2GREY:
			case ANIM_RED2GREY:  ACS_NamedExecuteAlways("Dominatrix_ApplyTranslation", 0, tid+MAXCONTROLPOINTS, TRANSLATION_GREY); break;
		}
		delay(6);
		Thing_Remove(tid+MAXCONTROLPOINTS);
		Thing_SpawnNoFog(tid, T_CPEYE, 0.0, tid+MAXCONTROLPOINTS);
		switch (animation)
		{
			case ANIM_GREY2BLUE: ACS_NamedExecuteAlways("Dominatrix_ApplyTranslation", 0, tid+MAXCONTROLPOINTS, TRANSLATION_BLUE); break;
			case ANIM_GREY2RED:  ACS_NamedExecuteAlways("Dominatrix_ApplyTranslation", 0, tid+MAXCONTROLPOINTS, TRANSLATION_RED); break;
			case ANIM_BLUE2GREY:
			case ANIM_RED2GREY:  ACS_NamedExecuteAlways("Dominatrix_ApplyTranslation", 0, tid+MAXCONTROLPOINTS, TRANSLATION_GREY); break;
		}
	}
	else
	{
		// Otherwise, use the DECORATE SetActorState functions
		switch (animation)
		{
			case ANIM_GREY2BLUE: SetActorState(tid+MAXCONTROLPOINTS, "Grey2Blue"); break;
			case ANIM_GREY2RED:  SetActorState(tid+MAXCONTROLPOINTS, "Grey2Red"); break;
			case ANIM_BLUE2GREY: SetActorState(tid+MAXCONTROLPOINTS, "Blue2Grey"); break;
			case ANIM_RED2GREY:  SetActorState(tid+MAXCONTROLPOINTS, "Red2Grey"); break;
		}
	}
}


/*===================================================================================================
                                        Dominatrix Functions
===================================================================================================*/

/*-------------------------------------------------------------
                    Dominatrix_FindEmptyCP

Finds an empty slot in the global control points array
Returns - The first empty index of the array, -1 if none was found, -2 if busy
-------------------------------------------------------------*/
function int Dominatrix_FindEmptyCP(void)
{
	// Make sure that if someone is already calling this function that it can't be called again by another script until finished
	if (global_cpslotmutex == false)
		return -2;

    // Find an empty spot in the control points global
    global_cpslotmutex = false;
	for (int i=0; i<MAXCONTROLPOINTS; i++)
    {
        // If we found an empty slot, mark it as not empty
        if (global_controlpoints[i][CPDATA_TID] == 0)
        {
            global_controlpoints[i][CPDATA_TID] = TID_CP+i;
            break;
        }

        // If we didn't find an empty slot, error.
        if (i == MAXCONTROLPOINTS-1)
        {
            Dominatrix_PrintConsoleBold(StrParam(s:"Too many control points. Max :", d:MAXCONTROLPOINTS));
            return -1;
        }
    }

	global_cpslotmutex = true;
    return i;
}

/*-------------------------------------------------------------
                     Dominatrix_PrintConsole

Print to the console of the activator using the DethTrak format
Argument 0 - A string with the message to print
-------------------------------------------------------------*/
function void Dominatrix_PrintConsole(str msg)
{
    HudMessage(s:msg; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, -1.0, -1.0, 0.0, 0.0);
}


/*-------------------------------------------------------------
                  Dominatrix_PrintConsoleBold

Print to everyone's console using the DethTrak format
Argument 0 - A string with the message to print
-------------------------------------------------------------*/
function void Dominatrix_PrintConsoleBold(str msg)
{
    HudMessageBold(s:msg; HUDMSG_LOG, MSGID_CONSOLE, CR_BLACK, -1.0, -1.0, 0.0, 0.0);
}

/*-------------------------------------------------------------
                       IsCompatibilityMode

Checks whether the passed compatibility mode is selected
Argument 0 - A String with the compatiblity mode to check
Returns - True if the compatibility mode is selected, false if otherwise
-------------------------------------------------------------*/
function bool IsCompatibilityMode(str compatMode)
{
	if (!global_zdaemoncompat)
		return !StrICmp(GetCVarString("dominatrix_compatibility"), compatMode);
	return true;
}

/*-------------------------------------------------------------
						 GetClientCVar
Gets a clientside CVar (for ZDaemon compatibility)
Argument 1 - An int with the ConsolePlayerNumber to check
Argument 1 - A string with the cvar to check
Returns - The value of the cvar
-------------------------------------------------------------*/
function bool GetClientCVar(int plynum, str cvar)
{
	if (IsCompatibilityMode("zdaemon"))
		return GetCvar(cvar);
	return GetUserCVar(plynum, cvar);
}

/*-------------------------------------------------------------
                            distance

Calculates the distance between two actors
Argument 0 - An int with the first actor's TID
Argument 1 - An int with the second actor's TID
Returns - The distance between both actors as an integer
-------------------------------------------------------------*/
function int distance(int tid1, int tid2)
{
    int len;
    int y = getactory(tid1) - getactory(tid2);
    int x = getactorx(tid1) - getactorx(tid2);
    int z = getactorz(tid1) - getactorz(tid2);

    int ang = vectorangle(x,y);
    if(((ang+0.125)%0.5) > 0.25) len = fixeddiv(y, sin(ang));
    else len = fixeddiv(x, cos(ang));

    ang = vectorangle(len, z);
    if(((ang+0.125)%0.5) > 0.25) len = fixeddiv(z, sin(ang));
    else len = fixeddiv(len, cos(ang));

    return len>>16;
}

/*-------------------------------------------------------------
                       SetActorInventory

Sets the value of an item on an Actor's inventoty
Argument 0 - An int with the TID of the actor to set the item
Argument 1 - A string with the name of the item to set
Argument 2 - An int with the amount of the item to set
-------------------------------------------------------------*/
function void SetActorInventory(int tid, str item, int amount)
{
    int diff = amount - CheckActorInventory(tid, item);
    if (diff > 0)
        GiveActorInventory(tid, item, diff);
    else if (diff < 0)
        TakeActorInventory(tid, item, -diff);
}

/*-------------------------------------------------------------
							HUDLoop

The HUD code that is called every frame
Argument 0 - The playernumber of the client
Argument 1 - Whether the player is spectating
-------------------------------------------------------------*/
function void HUDLoop(int plynum, bool isSpectator)
{
	str cpinfo1 = GetGlobalCVarString("__clientsync_cpinfo1");
	str cpinfo2 = GetGlobalCVarString("__clientsync_cpinfo2");
	int datalen1 = StrLen(cpinfo1);
	int datalen2 = StrLen(cpinfo2);

	// Get the resolution
	int scrW = 320;
	int scrH = 240;
	int timeToEnd = GetGlobalCVar("__clientsync_time");
	int ddomTime = GetGlobalCVar("__clientsync_ddomtime");
	if (GetClientCVar(plynum, "dominatrix_disablehudscale"))
	{
		scrW = GetScreenWidth();
		scrH = GetScreenHeight();
	}

	// Reset some HUD messages
	HudMessage(s:""; HUDMSG_PLAIN, MSGID_CPCAP1, CR_WHITE, 0.0, 0.0, 0.1);
	HudMessage(s:""; HUDMSG_PLAIN, MSGID_CPCAP2, CR_WHITE, 0.0, 0.0, 0.1);

	// Draw control point info
	int start1 = 0;
	int start2 = 0;
	for (int i=0; i<GetGlobalCVar("__clientsync_cpcount"); i++)
	{
		int j;
		str data1="";
		str data2="";
		for (j=start1; j<datalen1; j++)
		{
			if (GetChar(cpinfo1, j) == '\n')
			{
				data1 = StrMid(cpinfo1, start1, j-start1);
				start1 = j+1;
				break;
			}
		}
		for (j=start2; j<datalen2; j++)
		{
			if (GetChar(cpinfo2, j) == '\n')
			{
				data2 = StrMid(cpinfo2, start2, j-start2);
				start2 = j+1;
				break;
			}
		}
		CPInfoDraw(plynum, isSpectator, data1, data2, i, scrW, scrH);
	}

	// Set the hud size
	SetFont("DBIGFONT");
	SetHudSize(scrW, scrH, false);

	// Print the time
	if (GetGlobalCVar("__clientsync_gamestate") == GAME_RUNNING && timeToEnd != 0)
	{
		int timeY = 0.1;
		if (!GetClientCVar(plynum, "dominatrix_disableshowallcps") && GetGlobalCVar("__clientsync_cpcount") > 0)
			timeY = ((24*ceil(FixedDiv(GetGlobalCVar("__clientsync_cpcount")<<16, CPPERLINEHUD<<16)))<<16)+0.1;
		int time = ceil(FixedDiv((timeToEnd-Timer())<<16, SECOND<<16));
		int minutes = time/60;
		int seconds = time%60;
		str timestr = "";

		// Create the time string
		if (minutes < 10)
			timestr = "0";
		timestr = StrParam(s:timestr, d:minutes, s:":");
		if (seconds < 10)
			timestr = StrParam(s:timestr, s:"0");
		timestr = StrParam(s:timestr, d:seconds);

		// Print the time left
		HudMessage(s:timestr; HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_HUDTIME, CR_WHITE, (scrW/2 << 16), timeY, 1.0);

		// Handle the double domination time
		if (ddomTime != 0)
		{
			int color = CR_LIGHTBLUE;
			if (ddomTime < 0)
				color = CR_RED;
			timeY += 16.0;
			time = ceil(FixedDiv((abs(ddomTime)-Timer())<<16, SECOND<<16));
			minutes = time/60;
			seconds = time%60;
			timestr = "";

			if (minutes < 10)
				timestr = "0";
			timestr = StrParam(s:timestr, d:minutes, s:":");
			if (seconds < 10)
				timestr = StrParam(s:timestr, s:"0");
			timestr = StrParam(s:timestr, d:seconds);
			HudMessage(s:timestr; HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_HUDTIME2, color, (scrW/2 << 16), timeY, 1.0);
		}
		else
			HudMessage(s:""; HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_HUDTIME2, CR_WHITE, (scrW/2 << 16), 0.1, 1.0);
	}
	else
	{
		HudMessage(s:""; HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_HUDTIME, CR_WHITE, (scrW/2 << 16), 0.1, 1.0);
		HudMessage(s:""; HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_HUDTIME2, CR_WHITE, (scrW/2 << 16), 0.1, 1.0);
	}

	// Print the team scores
	SetFont("SMALLFONT");
	if (!GetClientCVar(plynum, "dominatrix_disablehudwidescreen"))
	{
		HudMessage(s:"score\n", d:GetGlobalCVar("__clientsync_bluescore"); HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_HUDBLUES, CR_LIGHTBLUE, -48.5, 0.1, 1.0);
		HudMessage(s:"score\n", d:GetGlobalCVar("__clientsync_redscore"); HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_HUDREDS, CR_RED, (scrW << 16)+48.6, 0.1, 1.0);
	}
	else
	{
		HudMessage(s:"score\n", d:GetGlobalCVar("__clientsync_bluescore"); HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_HUDBLUES, CR_LIGHTBLUE, 0.5, 0.1, 1.0);
		HudMessage(s:"score\n", d:GetGlobalCVar("__clientsync_redscore"); HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_HUDREDS, CR_RED, (scrW << 16)+0.6, 0.1, 1.0);
	}

	// If the game ended
	if (GetGlobalCVar("__clientsync_gameend") != END_NONE)
	{
		str gameover = "";

		// State why the game ended
		if (GetGlobalCVar("__clientsync_gameend") == END_TIME)
			gameover = "Time up!\n";
		else
			gameover = "Score limit reached!\n";

		// Attach the winner
		if (GetGlobalCVar("__clientsync_gamestate") == GAME_BLUEWIN)
			gameover = StrParam(s:gameover, s:"Blue Wins!");
		else if (GetGlobalCVar("__clientsync_gamestate") == GAME_REDWIN)
			gameover = StrParam(s:gameover, s:"Red Wins!");
		else if (GetGlobalCVar("__clientsync_gamestate") == GAME_DRAWWIN)
			gameover = StrParam(s:gameover, s:"Draw game!");

		// Print the winner
		SetFont("DBIGFONT");
		HudMessage(s:gameover; HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_HUDSTATE, CR_RED, (scrW/2 << 16)+0.4, (scrH/2 << 16)-32.0, 1.0);
	}
	else
		HudMessage(s:""; HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_HUDSTATE, CR_RED, (scrW/2 << 16), (scrH/2 << 16), 1.0);
}

/*-------------------------------------------------------------
					   PlayAnnouncement

Code that plays an announcement
Argument 0 - The playernumber of the client
Returns - true if we played a sound, false if otherwise
-------------------------------------------------------------*/
function void PlayAnnouncement(int plynum, int announcement)
{
	str sound = "Dominatrix/Announcer/";
	int plyteam = GetPlayerInfo(plynum, PLAYERINFO_TEAM);

	// Decide which sound to play
	switch(announcement)
	{
		case ANNOUNCE_BLUEGREY:
			if (plyteam == TEAM_BLUE)
				sound = StrParam(s:sound, s:"CPGrey", d:Random(1, 3));
			break;
		case ANNOUNCE_REDGREY:
			if (plyteam == TEAM_RED)
				sound = StrParam(s:sound, s:"CPGrey", d:Random(1, 3));
			break;
		case ANNOUNCE_BLUE:
			if (plyteam == TEAM_BLUE)
				sound = StrParam(s:sound, s:"CPGet", d:Random(1, 4));
			else
				sound = StrParam(s:sound, s:"CPLose", d:Random(1, 3));
			break;
		case ANNOUNCE_RED:
			if (plyteam == TEAM_RED)
				sound = StrParam(s:sound, s:"CPGet", d:Random(1, 4));
			else
				sound = StrParam(s:sound, s:"CPLose", d:Random(1, 3));
			break;
		case ANNOUNCE_BLUESCORE:
			return;
		case ANNOUNCE_REDSCORE:
			return;
		case ANNOUNCE_BLUEWIN:
			if (plyteam == TEAM_BLUE)
				sound = StrParam(s:sound, s:"WinGame", d:Random(1, 3));
			else
				sound = StrParam(s:sound, s:"LoseGame");
			break;
		case ANNOUNCE_REDWIN:
			if (plyteam == TEAM_RED)
				sound = StrParam(s:sound, s:"WinGame", d:Random(1, 3));
			else
				sound = StrParam(s:sound, s:"LoseGame");
			break;
		case ANNOUNCE_DRAWGAME:
			sound = StrParam(s:sound, s:"DrawGame");
			break;
		case ANNOUNCE_1MINUTE:
			sound = StrParam(s:sound, s:"1Minute");
			break;
		case ANNOUNCE_5MINUTES:
			sound = StrParam(s:sound, s:"5Minutes");
			break;
		case ANNOUNCE_1POINT:
			sound = StrParam(s:sound, s:"1PointLeft");
			break;
		case ANNOUNCE_2POINTS:
			sound = StrParam(s:sound, s:"2PointsLeft");
			break;
		case ANNOUNCE_3POINTS:
			sound = StrParam(s:sound, s:"3PointsLeft");
			break;
		case ANNOUNCE_50POINTS:
			sound = StrParam(s:sound, s:"50PointsLeft");
			break;
	}

	// Play the sound and return that we did
	LocalAmbientSound(sound, 127);
}

/*-------------------------------------------------------------
                          CPInfoDraw

Shows a Marker on a control point. Original code by Isle.
Argument 1 - The playernumber
Argument 2 - Whether the player is spectating
Argument 3 - The data1 of the CP in string format
Argument 4 - The data2 of the CP in string format
Argument 5 - The number of the CP
Argument 6 - The screen width
Argument 7 - The screen height
-------------------------------------------------------------*/
function void CPInfoDraw(int plynum, bool isSpectator, str cpdata1, str cpdata2, int cpNum, int scrW, int scrH)
{
	// HUD variables
	int dist, angle, vang, pitch, x, y;
	int hudX = 640;
	int hudY = 480;
	int xMarkerOffset = 0;
	int yMarkerOffset = -16;
	int plyteam = GetPlayerInfo(plynum, PLAYERINFO_TEAM);
	bool HUDYellow = (Timer()%(FONT_FLASHSPEED*2) > FONT_FLASHSPEED);
	int bobamouunt = 8.0;
	int bobspeed = 2000;
	bool capteamregen = GetCVar("dominatrix_capteamregen");
	int cpmaxhealth = GetCVar("dominatrix_caphealth");

	// CPData variables
	int cpx;
	int cpy;
	int cpz;
	int cpzbob;
	int cpteam;
	int cpstatus;
	int cpdatalen1 = StrLen(cpdata1);
	int cpdatalen2 = StrLen(cpdata2);

	// Draw HUD characters
	int cpback = BFONT_GREYBACK;
	int cpbacksmall = SFONT_GREYBACK;
	int cpbackmarker = SFONT_MARKERBACK;
	int cpinfosmall = SFONT_STARTCHAR;
	int cpinfomarker = SFONT_STARTCHAR;
	int cphealth = 0;
	int cphealthsmall = 0;
	int cpcolor = CR_UNTRANSLATED;

	// Extract the CP info from CPData1
	int i=0;
	int lastspace = 0;
	int datanum = 0;
	for (; i<cpdatalen1; i++)
	{
		if (GetChar(cpdata1, i) == ' ')
		{
			if (datanum == 0)
				cpx = AToI(StrMid(cpdata1, lastspace, i-lastspace));
			else if (datanum == 1)
				cpy = AToI(StrMid(cpdata1, lastspace, i-lastspace));

			datanum++;
			i++;
			lastspace = i;
		}
	}
	cpz = AToI(StrMid(cpdata1, lastspace, i-lastspace));
	cpzbob = 32.0+FixedMul(sin(Timer()*bobspeed), bobamouunt);

	// Extract the CP info from CPData2
	i=0;
	lastspace = 0;
	datanum = 0;
	for (; i<cpdatalen2; i++)
	{
		if (GetChar(cpdata2, i) == ' ')
		{
			if (datanum == 0)
				cpteam = AToI(StrMid(cpdata2, lastspace, i-lastspace));
			else if (datanum == 1)
				cpstatus = AToI(StrMid(cpdata2, lastspace, i-lastspace));

			datanum++;
			i++;
			lastspace = i;
		}
	}
	cphealth = AToI(StrMid(cpdata2, lastspace, i-lastspace));

	// Set the CP's back color to yellow if needed
	if ((cpstatus == CPSTATUS_STUCKRED || cpstatus == CPSTATUS_STUCKBLUE) && HUDYellow)
	{
		cpback = BFONT_YELLOWBACK;
		cpbacksmall = SFONT_YELLOWBACK;
		cpbackmarker = SFONT_MARKERYELLOW;
	}

	// Calculate CP health
	if (cpteam == TEAM_NONE)
		cphealthsmall = abs(cphealth/(cpmaxhealth/5));
	else if (cphealth == cpmaxhealth)
		cphealthsmall = 5;
	else
		cphealthsmall = (10-ceil(absf(FixedDiv(cphealth<<16, (cpmaxhealth/5)<<16))))%10;

	// Set the CP team color
	if (cphealth > 0)
		cpcolor = CR_BLUE;
	else
		cpcolor = CR_RED;

	// Set the extra info
	if (isSpectator && (cpstatus == CPSTATUS_BLUECAP || cpstatus == CPSTATUS_REDCAP))
	{
		cpinfosmall = SFONT_TEAMCAP;
		cpinfomarker = SFONT_MARKERTEAM;
	}
	else if (cpstatus == CPSTATUS_BLUECAP)
	{
		if (plyteam == TEAM_BLUE)
		{
			cpinfosmall = SFONT_TEAMCAP;
			cpinfomarker = SFONT_MARKERTEAM;
		}
		else if (plyteam == TEAM_RED)
		{
			cpinfosmall = SFONT_WARNING;
			cpinfomarker = SFONT_MARKERWARN;
		}
	}
	else if (cpstatus == CPSTATUS_REDCAP)
	{
		if (plyteam == TEAM_BLUE)
		{
			cpinfosmall = SFONT_WARNING;
			cpinfomarker = SFONT_MARKERWARN;
		}
		else if (plyteam == TEAM_RED)
		{
			cpinfosmall = SFONT_TEAMCAP;
			cpinfomarker = SFONT_MARKERTEAM;
		}
	}

	// Calculate things for marker placement
	SetHudSize(hudX, hudY, false);
	if (!GetClientCVar(plynum, "dominatrix_disablemarkers"))
	{
		x = cpx - GetActorX(0);
		y = cpy - GetActorY(0);
		vang = VectorAngle(x,y);
		angle = (vang - GetActorAngle(0) + 1.0) % 1.0;
		if(((vang+0.125)%0.5) > 0.25) dist = FixedDiv(y, sin(vang));
		else dist = FixedDiv(x, cos(vang));

		// Draw a marker on each command post
		if (angle < 0.2 || angle > 0.8)
		{
			if (GetActorPitch(0) >= -0.25 && GetActorPitch(0) <= 0.25)
			{
				pitch = VectorAngle(dist, (cpz+cpzbob) - (GetActorZ(0) + 41.0));
				pitch = (pitch + GetActorPitch(0) + 1.0) % 1.0;

				if ((hudX/2) * sin(angle) != 0 && cos(angle) != 0 && (hudX/2) * sin(pitch) != 0 && cos(pitch) != 0) //	Fixes divide by zero
				{
					x = hudX/2 - ((hudX/2) * sin(angle) / cos(angle));
					y = hudY/2 - ((hudX/2) * sin(pitch) / cos(pitch));

					x+=xMarkerOffset;
					y+=yMarkerOffset;

					SetFont("HUDSMALL");

					// Draw the background
					HudMessage(c:cpbackmarker; HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_CPBACK+cpNum, CR_UNTRANSLATED, (x << 16), (y << 16), 1.0);

					// Draw the color
					HudMessage(c:cphealthsmall+SFONT_MARKERSTART; HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_CPCOLR+cpNum, cpcolor, (x << 16), (y << 16), 1.0);

					// Draw extra CP status info
					HudMessage(c:cpinfomarker; HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_CPINFO+cpNum, CR_UNTRANSLATED, (x << 16), (y << 16), 1.0);
				}
			}
		}

		// Draw the CP being captured above the STATUSBAR
		if (!isSpectator)
		{
			if (GetCVar("dominatrix_capbelow") || (!GetCVar("dominatrix_capbelow") && GetActorZ(0)+CAPBELOW_HEIGHT >= cpz))
			{
				if ((dist>>16) < GetCVar("dominatrix_capdistance") && ((!capteamregen && plyteam != cpteam) || (capteamregen && abs(cphealth) < cpmaxhealth) || cphealth == 0))
				{
					int cphpdiv = abs((cphealth*42)/cpmaxhealth);
					SetHudSize(scrW, scrH, false);
					SetFont("HUDLARGE");

					// Draw the back of the CP HUD
					HudMessage(c:cpback; HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_CPCAP2, CR_UNTRANSLATED, (scrW/2) << 16, (scrH << 16)+0.2, 1.0);
					HudMessage(c:BFONT_STARTCHAR+cphpdiv; HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_CPCAP1, cpcolor, (scrW/2) << 16, (scrH << 16)+0.2, 1.0);
				}
			}
		}
	}

	// Draw the CP's on the top of the screen
	if (!GetClientCVar(plynum, "dominatrix_disableshowallcps"))
	{
		// Calculate the X and Y pos of the CP icon
		int maxW;
		int cpHUDY = FixedMul(24.0, floor(FixedDiv(cpNum<<16, CPPERLINEHUD<<16))<<16)-4.0+0.1;
		if (floor(FixedDiv(cpNum<<16, CPPERLINEHUD<<16)) == floor(FixedDiv(GetGlobalCVar("__clientsync_cpcount")<<16, CPPERLINEHUD<<16)))
			maxW = 24*((GetGlobalCVar("__clientsync_cpcount")%CPPERLINEHUD)-1);
		else
			maxW = 24*(CPPERLINEHUD-1);
		SetHudSize(scrW, scrH, false);
		SetFont("HUDSMALL");

		// Draw the back
		HudMessage(c:cpbacksmall; HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_CPBACKSM+cpNum, CR_UNTRANSLATED, (scrW/2-maxW/2+(cpNum%CPPERLINEHUD)*24) << 16, cpHUDY, 1.0);

		// Draw the color
		HudMessage(c:cphealthsmall+SFONT_STARTCHAR; HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_CPCOLRSM+cpNum, cpcolor, (scrW/2-maxW/2+(cpNum%CPPERLINEHUD)*24) << 16, cpHUDY, 1.0);

		// Draw the extra info
		HudMessage(c:cpinfosmall; HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP, MSGID_CPINFOSM+cpNum, CR_UNTRANSLATED, (scrW/2-maxW/2+(cpNum%CPPERLINEHUD)*24) << 16, cpHUDY, 1.0);
	}
}

/*-------------------------------------------------------------
                           HUDClear

Clears all the HUDMessages
-------------------------------------------------------------*/
function void HUDClear(void)
{
	HudMessage(s:""; HUDMSG_PLAIN, MSGID_HUDSTATE, CR_WHITE, 0.0, 0.0, 0.1);
	HudMessage(s:""; HUDMSG_PLAIN, MSGID_HUDREDS, CR_WHITE, 0.0, 0.0, 0.1);
	HudMessage(s:""; HUDMSG_PLAIN, MSGID_HUDBLUES, CR_WHITE, 0.0, 0.0, 0.1);
	HudMessage(s:""; HUDMSG_PLAIN, MSGID_HUDTIME, CR_WHITE, 0.0, 0.0, 0.1);
	HudMessage(s:""; HUDMSG_PLAIN, MSGID_HUDTIME2, CR_WHITE, 0.0, 0.0, 0.1);
	HudMessage(s:""; HUDMSG_PLAIN, MSGID_CPCAP1, CR_WHITE, 0.0, 0.0, 0.1);
	HudMessage(s:""; HUDMSG_PLAIN, MSGID_CPCAP2, CR_WHITE, 0.0, 0.0, 0.1);
	HudMessage(s:""; HUDMSG_PLAIN, MSGID_CPINFO, CR_WHITE, 0.0, 0.0, 0.1);

	for (int i=0; i<MAXCONTROLPOINTS+1; i++)
	{
		HudMessage(s:""; HUDMSG_PLAIN, MSGID_CPCOLR+i, CR_WHITE, 0.0, 0.0, 0.1);
		HudMessage(s:""; HUDMSG_PLAIN, MSGID_CPBACK+i, CR_WHITE, 0.0, 0.0, 0.1);
		HudMessage(s:""; HUDMSG_PLAIN, MSGID_CPINFOSM+i, CR_WHITE, 0.0, 0.0, 0.1);
		HudMessage(s:""; HUDMSG_PLAIN, MSGID_CPCOLRSM+i, CR_WHITE, 0.0, 0.0, 0.1);
		HudMessage(s:""; HUDMSG_PLAIN, MSGID_CPBACKSM+i, CR_WHITE, 0.0, 0.0, 0.1);
	}
}

/*-------------------------------------------------------------
                         SetGlobalCVar

Changes the value of a global cvar if it is different
Argument 0 - The cvar to change
Argument 1 - The value to set it to
-------------------------------------------------------------*/
function void SetGlobalCVar(str cvar, int value)
{
    if (GetCVar(cvar) != value)
        SetCVar(cvar, value);
}

/*-------------------------------------------------------------
                      SetGlobalCVarString

Changes the value of a global cvar string if it is different
Argument 0 - The cvar string to change
Argument 1 - The value to set it to
-------------------------------------------------------------*/
function void SetGlobalCVarString(str cvar, str value)
{
    if (GetCVarString(cvar) != value)
        SetCVarString(cvar, value);
}

/*-------------------------------------------------------------
						 GetGlobalCVar

A multi source port compatible version of GetCvar for my
networking system.
Argument 0 - The CVar to get the value of
-------------------------------------------------------------*/
function int GetGlobalCVar(str cvar)
{
	if (!IsCompatibilityMode("zdaemon"))
		return GetCvar(cvar);

	// Messy but required for ZDaemon compatibility
	int value = 0;
	if (!StrCmp(cvar, "__clientsync_time")) value = global_time;
	else if (!StrCmp(cvar, "__clientsync_redscore")) value = global_scoreteamred;
	else if (!StrCmp(cvar, "__clientsync_bluescore")) value = global_scoreteamblue;
	else if (!StrCmp(cvar, "__clientsync_gamestate")) value = global_gamestate;
	else if (!StrCmp(cvar, "__clientsync_cpcount")) value = global_cpcount;
	else if (!StrCmp(cvar, "__clientsync_announce")) value = global_announcement;
	else if (!StrCmp(cvar, "__clientsync_gameend")) value = global_gameend;
	else if (!StrCmp(cvar, "__clientsync_ddomtime")) value = global_ddomtime;
	return value;
}

/*-------------------------------------------------------------
					  GetGlobalCVarString

A multi source port compatible version of GetCvarString for my
networking system.
Argument 0 - The CVar to get the value of
-------------------------------------------------------------*/
function str GetGlobalCVarString(str cvar)
{
	if (!IsCompatibilityMode("zdaemon"))
		return GetCvarString(cvar);

	// Pack the control point info into a string
	str cpinfo = "";
	int i;
	if (!StrCmp(cvar, "__clientsync_cpinfo1"))
	{
		for (i=0; i<MAXCONTROLPOINTS; i++)
		{
			if (global_controlpoints[i][CPDATA_TID] != 0)
			{
				cpinfo = StrParam(s:cpinfo, d:global_controlpoints[i][CPDATA_X], s:" ",
										    d:global_controlpoints[i][CPDATA_Y], s:" ",
											d:global_controlpoints[i][CPDATA_Z], c:'\n');
			}
		}
	}
	else
	{
		for (i=0; i<MAXCONTROLPOINTS; i++)
		{
			if (global_controlpoints[i][CPDATA_TID] != 0)
			{
				cpinfo = StrParam(s:cpinfo, d:global_controlpoints[i][CPDATA_TEAM], s:" ",
											d:global_controlpoints[i][CPDATA_STATUS], s:" ",
											d:global_controlpoints[i][CPDATA_CAPAMOUNT], c:'\n');
			}
		}
	}
	return cpinfo;
}

/*-------------------------------------------------------------
							  AToI
Converts a string to an integer
Argument 1 - The string to convert
Returns - An integer with the number
-------------------------------------------------------------*/
function int AToI (str s)
{
    bool negative = false;
    int n = 0;
    int len = StrLen(s);

    // Go through every character in the string
    for (int i = 0; i < len; i++)
    {
        int char = GetChar(s, i);

        // Check if we found a negative sign
        if (i == 0 && char == '-')
        {
            negative = true;
            continue;
        }

        // Check that we are actually converting a number
        if (char < '0' || char > '9')
        {
            print(s:"ERROR, attempting to convert ", c:char, s:" to number!");
            continue;
        }

        // Add the number to our total
        n = n*10 + (char-'0');
    }

    if (negative)
        n = -n;

    return n;
}

/*-------------------------------------------------------------
							  abs
Returns the absolute value of a number
Argument 1 - An int to apply absolute value on
Returns - A positive integer
-------------------------------------------------------------*/
function int abs(int x)
{
    if (x < 0)
        return -x;
    return x;
}

/*-------------------------------------------------------------
							  absf
Returns the absolute value of a fixed point number
Argument 1 - An fixed point to apply absolute value on
Returns - A positive fixed point number
-------------------------------------------------------------*/
function int absf(int x)
{
    if (x < 0.0)
        return -x;
    return x;
}

/*-------------------------------------------------------------
							 floor
Removes the decimal part of a fixed number and spits out an int
Argument 1 - A fixed number
Returns - A whole integer
-------------------------------------------------------------*/
function int floor(int fixedNumber)
{
	return (fixedNumber & 0xFFFF0000) >> 16;
}

/*-------------------------------------------------------------
							 ceil
Rounds a fixed point number up (only works for positive values)
Argument 1 - A fixed number
Returns - A whole integer
-------------------------------------------------------------*/
function int ceil(int fixedNumber)
{
	return ((fixedNumber + 65535) & 0xFFFF0000) >> 16;
}